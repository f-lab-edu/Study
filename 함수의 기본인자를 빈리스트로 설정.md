## 기본 인자는 “함수를 호출할 때”가 아니라 “함수가 정의될 때” 한 번만 만들어진다

아래 코드에서 `[]`는 `f()`를 부를 때마다 새로 만들어지는 게 아니라,  
`def f(...)`가 실행되는 순간 한 번 만들어져서 함수 내부에 저장된다.

그래서 인자를 생략하고 `f()`를 여러 번 호출하면, 파이썬은 매번 **똑같은 리스트 객체**를 `a`로 사용한다.

+
Mutable(가변)은 생성 후 객체의 내용이나 상태를 변경할 수 있는 것이고, Immutable(불변)은 생성 후 내용이 변하지 않는 것

## 기본인자가 빈 리스트인 함수 실행 결과

```Python
def f(a=[]):
    a.append(10)
    return a
    
    
print(f())  
print(f())  
print(f())

# 실행결과
# [10] 
# [10, 10] 
# [10, 10, 10] 
```

## 왜 누적될까?

- 기본값 `[]`는 “공용 리스트(한 개)”로 함수 안에 저장되어 있음
    
- `append()`는 리스트를 **제자리에서 수정(뮤테이션)** 하는 메서드
    
- 그래서 한 번 추가된 값이 다음 호출에서도 그대로 남는다

## `.__defaults__`로 확인하기



기본 인자는 함수 객체 안에 저장되며, `__defaults__` 속성으로 볼 수 있다.


```python
def f(a=[]):
    return a

print(f.__defaults__)  

#결과 
# ([],)
```

그리고 실제 호출에서 쓰이는 `a`도 그 기본값과 같은 객체인지 확인할 수 있다.

``` python
def f(a=[]):

    return id(a), id(f.__defaults__[0])

print(f())  
print(f())

# 결과
# (2636315166656, 2636315166656)
# (2636315166656, 2636315166656)
```


## immutable 한 경우

``` python

def f(a=5):

    a = a + 10

    return a

print(f())  
print(f())  
print(f())

#결과
# 15
# 15
# 15
```

반대로 `int`처럼 불변(immutable) 타입은 `a += 10`을 해도 원본을 바꾸지 못하고 **새 객체로 재할당**되므로, 기본값이 누적(오염)되지 않는다.

## 결론

- 기본 인자 `[]`는 호출마다 새로 만들어지지 않는다.
    
- 함수 정의 시점에 한 번 생성되어, **같은 리스트 객체가 계속 재사용**된다.
    
- 리스트는 뮤터블이라 `append/extend/a[i]=...` 같은 **제자리 수정**을 하면(=리스트 객체 자체가 바뀜), 기본 인자가 같은 객체로 재사용되는 만큼 그 변경이 다음 호출에도 남아 누적된다.
    
- 정석은 `None`을 기본값으로 두고 함수 내부에서 새 리스트를 만드는 방식이다.